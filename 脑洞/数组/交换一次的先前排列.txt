题目难度：MEDIUM
给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。

如果无法这么操作，就请返回原数组。

 

示例 1：

输入：[3,2,1]
输出：[3,1,2]
解释：
交换 2 和 1
 

示例 2：

输入：[1,1,5]
输出：[1,1,5]
解释： 
这已经是最小排列
 

示例 3：

输入：[1,9,4,6,7]
输出：[1,7,4,6,9]
解释：
交换 9 和 7
 

示例 4：

输入：[3,1,1,3]
输出：[1,1,3,3]
 

提示：

1 <= A.length <= 10000
1 <= A[i] <= 10000

思路：从后往前遍历，从倒数第二个开始（因为最后一个是最大值的话不需要改变位置）找到左大于右的值，
在从最后开始向前便利找比上一个值小的值即可
（别问为啥不会，不会就是题没读懂。。。）

代码：
class Solution {
public:
    vector<int> prevPermOpt1(vector<int>& A) {
        int N = A.size();
        int pos1 = -1;
        for (int i = N - 2; i >= 0; i--) {
            if (A[i]> A[i+1]) {
                pos1 = i;
                break;
            }
        }
        if (pos1 != -1) {
            for (int i = N - 1; i >= 0; i--) {
                if (A[i] < A[pos1]) {
                    swap(A[i], A[pos1]);
                    break;
                }
            }
        }
        return A;
    }
};