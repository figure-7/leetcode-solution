给定一个整数数组 A，返回满足下面条件的 非空、连续 子数组的数目：

子数组中，最左侧的元素不大于其他元素。

 

示例 1：

输入：[1,4,2,5,3]
输出：11
解释：有 11 个有效子数组，分别是：[1],[4],[2],[5],[3],[1,4],[2,5],[1,4,2],[2,5,3],[1,4,2,5],[1,4,2,5,3] 。
示例 2：

输入：[3,2,1]
输出：3
解释：有 3 个有效子数组，分别是：[3],[2],[1] 。
示例 3：

输入：[2,2,2]
输出：6
解释：有 6 个有效子数组，分别为是：[2],[2],[2],[2,2],[2,2],[2,2,2] 。


不会。。。
class Solution
{
	public:
		int validSubarrays(vector<int>& nums)
		{
			int l = 0;
			int r = 0;
			int res = 0;
			for(int i=0; i<nums.size(); ++i)
			{
				while(r<nums.size() && nums[r]>=nums[l])
				{
					r ++;
				}
				res += r-l;
				l ++;
				r = l;
			}
			return res;
		}
};