题目难度：HARD

给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。

在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。

你可以按以下方式从索引 i 向后跳转到索引 j（其中 i < j）：

在进行奇数跳跃时（如，第 1，3，5... 次跳跃），你将会跳到索引 j，使得 A[i] <= A[j]，A[j] 是可能的最小值。
如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。
在进行偶数跳跃时（如，第 2，4，6... 次跳跃），你将会跳到索引 j，使得 A[i] => A[j]，A[j] 是可能的最大值。
如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。
（对于某些索引 i，可能无法进行合乎要求的跳跃。）
如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 A.length - 1），那么该索引就会被认为是好的起始索引。

返回好的起始索引的数量。

 

示例 1：

输入：[10,13,12,14,15]
输出：2
解释： 
从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。
从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。
从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。
从起始索引 i = 4 出发，我们已经到达数组末尾。
总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。
示例 2：

输入：[2,3,1,1,4]
输出：3
解释：
从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：

在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。

在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。

A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。

在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。

我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。

类似地，我们可以推断：
从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。
从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。
从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。
从起始索引 i = 4 出发，我们已经到达数组末尾。
总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。
示例 3：

输入：[5,1,3,4,2]
输出：3
解释： 
我们可以从起始索引 1，2，4 出发到达数组末尾。
 

提示：

1 <= A.length <= 20000
0 <= A[i] < 100000

思路：栈+DP
接下来上题解区题解;
针对奇数和偶数的情形，我们分别需要找到当前位置后，大于等于它的数中值最小且索引最小的位置，以及小于等于它的数中值最大且索引最小的位置。
考虑到nn的规模，使用朴素的遍历搜索显然会导致超时。
因为存在大小比较，我们考虑进行排序。
由于值和索引都需要比较，我们不能直接对原数组进行排序，而是利用sort函数的可选参数，传递一个自定义比较函数，来排序一个原始值为0...n-10...n−1的order数组。
对于奇数（找比当前数大的数）的情形，我们按值和索引升序排序order数组。
对于偶数情形，我们按值降序，索引升序排序order数组。
不难发现，在排序之后，我们只要在order数组中找到第一个比当前索引大的索引，它就代表了当前索引的后继。
找第一个比当前数大的数，这一目标明确了之后，方法也自然浮出了水面：
单调栈。
这里，我们维护一个从栈底到栈顶为降序的单调栈，在新元素加入时，如果它大于当前的栈顶元素，就将其作为栈顶元素的后继，并将栈顶元素出栈。
如此循环，直到栈空，或栈顶元素大于新元素为止。
在分别确定了奇数和偶数情况下的后继之后，我们使用两个数组canodd和caneven，分别记录从当前元素开始，以“奇-偶-奇”和“偶-奇-偶”的方式是否能够跳跃到终点n-1n−1。
边界条件是，canodd[n-1]=true，caneven[n-1]=true。
我们从n-2n−2一直递减到00，不断更新对应的canodd[i]和caneven[i]。
最后，统计canodd数组中为true的个数，即为我们需要的答案。


执行用时 :
80 ms
, 在所有 C++ 提交中击败了
88.24%
的用户
内存消耗 :
21.3 MB
, 在所有 C++ 提交中击败了
20.00%
的用户
（时间很好，空间不太好）

上代码：
class Solution {
    vector<int> mono(vector<int> &order) {
        int n = order.size();
        vector<int> nxt(n, -1);
        stack<int> st;
        st.push(order[0]);
        for (int i = 1; i < n; ++i) {
            while (!st.empty() && st.top() < order[i]) {
                nxt[st.top()] = order[i];
                st.pop();
            }
            st.push(order[i]);
        }
        return nxt;
    }
public:
    int oddEvenJumps(vector<int>& A) {
        int n = A.size();
        vector<int> order(n);
        for (int i = 0; i < n; ++i)
            order[i] = i;
        sort(order.begin(), order.end(), [&](int i ,int j) {
           return A[i] < A[j] || (A[i] == A[j] && i < j); 
        });
        vector<int> nxtlarger = mono(order);
        
        sort(order.begin(), order.end(), [&](int i ,int j) {
           return A[i] > A[j] || (A[i] == A[j] && i < j); 
        });
        vector<int> nxtsmaller = mono(order);
        vector<bool> canodd(n), caneven(n);
        caneven[n - 1] = true;
        canodd[n - 1] = true;
        for (int i = n - 2; i >= 0; --i) {
            int nl = nxtlarger[i], ns = nxtsmaller[i];
            if (nl != -1 && caneven[nl])
                canodd[i] = true;
            
            if (ns != -1 && canodd[ns])
                caneven[i] = true;
        }
        int ans = 0;
        for (int i = 0; i < n; ++i)
            ans += canodd[i];
        return ans;
    }
};
