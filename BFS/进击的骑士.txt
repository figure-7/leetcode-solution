题目难度：MEDIUM

一个坐标可以从 -infinity 延伸到 +infinity 的 无限大的 棋盘上，你的 骑士 驻扎在坐标为 [0, 0] 的方格里。

骑士的走法和中国象棋中的马相似，走 “日” 字：即先向左（或右）走 1 格，再向上（或下）走 2 格；或先向左（或右）走 2 格，再向上（或下）走 1 格。

每次移动，他都可以按图示八个方向之一前进。



现在，骑士需要前去征服坐标为 [x, y] 的部落，请你为他规划路线。

最后返回所需的最小移动次数即可。本题确保答案是一定存在的。

 

示例 1：

输入：x = 2, y = 1
输出：1
解释：[0, 0] → [2, 1]
示例 2：

输入：x = 5, y = 5
输出：4
解释：[0, 0] → [2, 1] → [4, 2] → [3, 4] → [5, 5]
 

提示：

|x| + |y| <= 300

思路：一开始就想到了BFS，于是直接手写了一个BFS递归八项封印，结果结果一支不对，可能是吧最大次数保存了，改了半天没出来
真的难受啊，又是没能3题。。。
后来看前几得题解都是队列+枚举，算了我以后也这么写好了，主义之前下标都加了400为的是正数便于后续书写运算

上代码：
int dx[] = {-2, -2, -1, -1, 1, 1, 2, 2};
int dy[] = {-1, 1, -2, 2, -2, 2, -1, 1};

int H[888][888];

class Solution {
public:
    using pii = pair<int, int>;
    int minKnightMoves(int x, int y) {
        int xt = abs(x);
        int yt = abs(y);
        for (int i = -321; i <= 321; ++ i)
            for (int j = -321; j <= 321; ++ j)
                H[i+400][j+400] = -1;
        H[0+400][0+400] = 0;
        queue<pii> Q;
        Q.push({0, 0});
        while (!Q.empty())
        {
            auto [x, y] = Q.front();
            Q.pop();
            if (x == xt && y == yt) return H[x+400][y+400];
            for (int k = 0; k < 8; ++ k)
            {
                int tx = x+dx[k], ty = y+dy[k];
                if (H[tx+400][ty+400] == -1)
                {
                    H[tx+400][ty+400] = H[x+400][y+400]+1;
                    Q.push({tx, ty});
                    if (tx == xt && ty == yt) return H[tx+400][ty+400];
                }
            }
        }
        return -1;
    }
};