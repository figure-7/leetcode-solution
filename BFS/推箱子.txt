题目难度：HARD

「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。


游戏地图用大小为 n * m 的网格 grid 表示，其中每个元素可以是墙、地板或者是箱子。


现在你将作为玩家参与游戏，按规则将箱子?'B'?移动到目标位置?'T' ：

玩家用字符?'S'?表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。

地板用字符?'.'?表示，意味着可以自由行走。

墙用字符?'#'?表示，意味着障碍物，不能通行。?

箱子仅有一个，用字符?'B'?表示。
相应地，网格上有一个目标位置?'T'。
玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。
记作一次「推动」。
玩家无法越过箱子。

返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回?-1。

?



示例 1：



输入：grid = [["#","#","#","#","#","#"],

              	      ["#","T","#","#","#","#"],

?            	      ["#",".",".","B",".","#"],

?            	      ["#",".","#","#",".","#"],

?            	      ["#",".",".",".","S","#"],

?            	      ["#","#","#","#","#","#"]]

输出：3

解释：我们只需要返回推箱子的次数。


示例 2：

输入：grid = [["#","#","#","#","#","#"],

             	      ["#","T","#","#","#","#"],

?            	      ["#",".",".","B",".","#"],

?            	      ["#","#","#","#",".","#"],

?            	      ["#",".",".",".","S","#"],

?            	      ["#","#","#","#","#","#"]]

输出：-1


示例 3：

输入：grid = [["#","#","#","#","#","#"],

?                    ["#","T",".",".","#","#"],

?                    ["#",".","#","B",".","#"],

?                    ["#",".",".",".",".","#"],

?                    ["#",".",".",".","S","#"],

?                    ["#","#","#","#","#","#"]]

输出：5

解释：向下、向左、向左、向上再向上。


示例 4：

输入：grid = [["#","#","#","#","#","#","#"],

?                    ["#","S","#",".","B","T","#"],

?                    ["#","#","#","#","#","#","#"]]

输出：-1
?


提示：

1 <= grid.length <= 20
	1 <= grid[i].length <= 20

grid 仅包含字符?'.', '#',? 'S' , 'T', 以及?'B'。

grid?中?'S', 'B'?和?'T'?各只能出现一个。

思路：这是我见过最难的一道BFS，无边界固定值，走法有限制
利用BFS+dijstra+结构体的方法
针对人是否能走，走了后步数是否加一，前方是否有箱子，有箱子的话是否能推动
其余就是模板了，BFS看箱子能不能到终点，不能返回-1即可
能的话就利用dijstra的到单源最短路径（即最少步数）

上代码：
int vis[25][25][25][25];
class Solution {
public:
    //vector<vector<char> > g;
    int n,m;
    int dx[4]={0,0,-1,1};
    int dy[4]={-1,1,0,0};
    struct Node
    {
        int x,y,bx,by,d;
        Node(int x=0,int y=0,int bx=0,int by=0,int d=0)
            :x(x),y(y),bx(bx),by(by),d(d){}
        bool operator<(const Node &B) const
        {
            return d>B.d;
        }
    };
    int minPushBox(vector<vector<char>>& g) {
        //g=grid;
        n=g.size();
        m=g[0].size();
        memset(vis,-1,sizeof(vis));
        int stx=-1,sty=-1,edx=-1,edy=-1;
        int px=-1,py=-1;
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
            {
                if(g[i][j]=='B')
                    stx=i,sty=j;
                else if(g[i][j]=='T')
                    edx=i,edy=j;
                else if(g[i][j]=='S')
                    px=i,py=j;
            }
        priority_queue<Node> qu;
        qu.emplace(px,py,stx,sty,0);
        vis[px][py][stx][sty]=0;
        while(!qu.empty())
        {
            Node node=qu.top(); qu.pop();
            int nx=node.x,ny=node.y,nbx=node.bx,nby=node.by;
            int nd=vis[nx][ny][nbx][nby];
            if(nbx==edx&&nby==edy) return vis[nx][ny][edx][edy];
            //cout<<nx<<" "<<ny<<" "<<nbx<<" "<<nby<<endl;
            for(int i=0;i<4;i++)
            {
                int x=dx[i]+nx,y=dy[i]+ny;
                if(x<0||n<=x||y<0||m<=y) continue;
                if(g[x][y]=='#') continue;
                if(x==nbx&&y==nby) //push
                {
                    int bx=dx[i]+nbx,by=dy[i]+nby;
                    if(bx<0||n<=bx||by<0||m<=by) continue;
                    if(g[bx][by]=='#') continue;
                    if(vis[x][y][bx][by]!=-1&&vis[x][y][bx][by]<=nd+1) continue;
                    vis[x][y][bx][by]=nd+1;
                    qu.emplace(x,y,bx,by,nd+1);
                }
                else if(vis[x][y][nbx][nby]==-1||vis[x][y][nbx][nby]>nd)
                {
                    vis[x][y][nbx][nby]=nd;
                    qu.emplace(x,y,nbx,nby,nd);
                }
                //cout<<i<<endl;
            }
        }
        return -1;
    }
};
/*
[["#","#","#","#","#","#"],["#","T","#","#","#","#"],["#",".",".","B",".","#"],["#",".","#","#",".","#"],["#",".",".",".","S","#"],["#","#","#","#","#","#"]]
[["#","#","#","#","#","#"],["#","T","#","#","#","#"],["#",".",".","B",".","#"],["#","#","#","#",".","#"],["#",".",".",".","S","#"],["#","#","#","#","#","#"]]
[["#","#","#","#","#","#"],
               ["#","T",".",".","#","#"],
               ["#",".","#","B",".","#"],
               ["#",".",".",".",".","#"],
               ["#",".",".",".","S","#"],
               ["#","#","#","#","#","#"]]
*/