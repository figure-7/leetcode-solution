题目难度：MEDIUM

给定一个由 '1'（陆地）和 '0'（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。
你可以假设网格的四个边均被水包围。

示例 1:

输入:
11110
11010
11000
00000

输出: 1
示例 2:

输入:
11000
11000
00100
00011

输出: 3

思路：bfs 代码很简洁 美观 每次遇到1就bfs ，如果这个表格很大的话需要用并查集 将矩阵分隔成若干小的矩阵
每次遇见1就把先累加，再把横纵列相邻的值变为0，直至结束
对于例一：变化如下
11110
11010
11000
00000

10
0

100
00
0

1000
000
00
0

10000
0000
000
00    

......

对于例二:
11000
11000
00100
00011

1

10
0

100
00
0

1000
000
00
0

10000
0000
001
00

10000
00000
0010
000


10000
00000
00100
0001

10000
00000
00100
00010

执行用时 :
20 ms
, 在所有 C++ 提交中击败了
82.26%
的用户
内存消耗 :
10.8 MB
, 在所有 C++ 提交中击败了
83.91%
的用户

上代码：
class Solution {
public:
    void bfs(vector<vector<char>>& grid, int x, int y) {
	if (x >= 0 && x < grid.size() && y >= 0 && y < grid[0].size() && grid[x][y] == '1') {
		grid[x][y] = '0';
		bfs(grid, x - 1, y);
		bfs(grid, x + 1, y);
		bfs(grid, x, y - 1);
		bfs(grid, x, y + 1);
	}
}

int numIslands(vector<vector<char>>& grid) {
	int sum = 0;
	for (int i = 0; i < grid.size(); i++) {
		for (int j = 0; j < grid[0].size(); j++) {
			if (grid[i][j] == '1') {
				sum++;
				bfs(grid, i, j);
			}
		}
	}
	return sum;
}

};