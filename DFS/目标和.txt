题目难度：MEIDUM
给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

示例 1:

输入: nums: [1, 1, 1, 1, 1], S: 3
输出: 5
解释: 

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3

一共有5种方法让最终目标和为3。
注意:

数组非空，且长度不会超过20。
初始的数组的和不会超过1000。
保证返回的最终结果能被32位整数存下。

思路：DFS 或 DFS+记忆化搜索 或 树形dp
（这题有毒，我跟题解区一样的思路复杂度，结果我的就超时，题解区的以1600+ms的速度过了！！！时间击败10%。。。）
DFS回溯的方法就不说了，说了都是泪，接下来换题解区树形dp的思路：
一句话：有点类似树形dp，分别向左右两种情况要满足条件的数目。

执行用时 :
1408 ms
, 在所有 cpp 提交中击败了
32.64%
的用户
内存消耗 :
8.4 MB
, 在所有 cpp 提交中击败了
93.48%
的用户
（时间也够慢，空间很好）

上代码：
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int S) {        
        return dfs(nums, S, 0, 0);
    }

    int dfs(vector<int>& nums, int S, int i, int sum) {
        if (i == nums.size()) {
            return S == sum ? 1 : 0;
        }                
        return dfs(nums, S, i + 1, sum + nums[i]) + dfs(nums, S, i + 1, sum - nums[i]);        
    }
};