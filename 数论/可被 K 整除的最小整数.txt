题目难度：MEDIUM

给定正整数 K，你需要找出可以被 K 整除的、仅包含数字 1 的最小正整数 N。

返回 N 的长度。如果不存在这样的 N，就返回 -1。

 

示例 1：

输入：1
输出：1
解释：最小的答案是 N = 1，其长度为 1。
示例 2：

输入：2
输出：-1
解释：不存在可被 2 整除的正整数 N 。
示例 3：

输入：3
输出：3
解释：最小的答案是 N = 111，其长度为 3。
 

提示：

1 <= K <= 10^5

思路：数论
接下来上题解区题解：
无

执行用时 :
8 ms
, 在所有 C++ 提交中击败了
40.76%
的用户
内存消耗 :
8.8 MB
, 在所有 C++ 提交中击败了
32.00%
的用户
（时间一般，空间不咋地）

上代码：
class Solution {
public:
    int smallestRepunitDivByK(int K) {
        vector<bool> seen(K, false);
        int n = 0;
        int c = 0;
        while (!seen[n]) {
            seen[n] = true;
            n = (10 * n + 1) % K;
            ++c;
        }
        return (n == 0) ? c : -1;
    }
};