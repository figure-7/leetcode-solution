题目难度：EASY

给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。
示例 1:
输入: num = 38
输出: 2 
解释: 各位相加的过程为：
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2
由于 2 是一位数，所以返回 2。
示例 1:
输入: num = 0
输出: 0
提示：
0 <= num <= 231 - 1 
进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？

思路：数论
难在进阶，接下来上题解区题解：
假设整数num 的十进制表示有 nn 位，从最低位到最高位依次是 a_0a 
0
  到 a_{n - 1}a 
n−1
 ，则num 可以写成如下形式：
\begin{aligned} \textit{num} &= \sum_{i = 0}^{n - 1} a_i \times 10^i \\ &= \sum_{i = 0}^{n - 1} a_i \times (10^i - 1 + 1) \\ &= \sum_{i = 0}^{n - 1} a_i \times (10^i - 1) + \sum_{i = 0}^{n - 1} a_i \end{aligned}
num
= 
i=0
∑
n−1
 a 
i
 ×10 
i
= 
i=0
∑
n−1
 a 
i
 ×(10 
i
 −1+1)
= 
i=0
∑
n−1
 a 
i
 ×(10 
i
 −1)+ 
i=0
∑
n−1
 a 
i
当 i = 0i=0 时，10^i - 1 = 010 
i
 −1=0 是 99 的倍数；
当 ii 是正整数时，10^i - 110 
i
 −1 是由 ii 位 99 组成的整数，也是 99 的倍数。
因此对于任意非负整数 ii，10^i - 110 
i
 −1 都是 9 的倍数。
由此可得 num 与其各位相加的结果模 9 同余。
重复计算各位相加的结果直到结果为一位数时，该一位数即为num 的数根，num 与其数根模 9 同余。
我们对 num 分类讨论：
num 不是 9 的倍数时，其数根即为num 除以 9 的余数。
num 是 9 的倍数时：
如果num=0，则其数根是 0；
如果num>0，则各位相加的结果大于 0，其数根也大于 0，因此其数根是 9。
细节
根据上述分析可知，当 num>0 时，其数根的结果在范围 [1,9] 内，因此可以想到计算num−1 除以 9 的余数然后加 1。
由于当num>0 时，num−1≥0，非负数除以 9 的余数一定也是非负数，因此计算num−1 除以 9 的余数然后加 1 的结果是正确的。
当num=0 时，num−1=−1<0，负数对 9 取余或取模的结果的正负在不同语言中有所不同。
对于取余的语言，结果的正负和左操作数相同，则num−1 对 9 取余的结果为 −1，加 1 后得到结果 0，可以得到正确的结果；
对于取模的语言，结果的正负和右操作数相同，则num−1 对 9 取模的结果为 8，加 1 后得到结果 9，无法得到正确的结果，此时需要对num=0 的情况专门做处理。

执行用时：
0 ms
, 在所有 C++ 提交中击败了
100.00%
的用户
内存消耗：
5.7 MB
, 在所有 C++ 提交中击败了
90.19%
的用户
（时间完杀！！！空间很好）

上代码：
class Solution {
public:
    int addDigits(int num) {
        return (num - 1) % 9 + 1;
    }
};
