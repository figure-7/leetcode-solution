题目难度：EASY

0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。

求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

示例 1：

输入: n = 5, m = 3
输出: 3
示例 2：

输入: n = 10, m = 17
输出: 2
 

限制：

1 <= n <= 10^5
1 <= m <= 10^6

思路：数论
首先队列超时，导下标吗没出来
接下来上题解区题解：
约瑟夫问题比较难想的点有两个：

当数到最后一个结点不足m个时，需要跳到第一个结点继续数。
每轮都是上一轮被删结点的下一个结点开始数 m 个。
第一点比较好解决，可以通过取余来完成。
第二点的解决方案是：
将删除结点的后继作为下一轮的第一个结点，后续结点依次排列。
这样每轮都是从首结点开始数 m 个了。



通过观察上图中的结点对应关系可以发现：
设下一轮的最后结点编号为 p，那么当前一轮的最后结点为从被删除结点向后偏移 p+1 处的结点 ！！！
换一个更好用代码实现的描述方式：
从被删除结点的下一个结点偏移 p 处的结点，编号为 ((m%n) + p)%n
一个递推式子已经呼之欲出了！！！
OMG ！！！
设函数 f(n,m) 输出最后结点的编号，结点编号从 0 开始，n 为结点个数，m 为删除步长。

f(n,m) = \left\{ \begin{array}{c} 0, &n = 1 \\ ((m\%n) + f(n-1, m))\%n, &n > 1 \\ \end{array}\right.
f(n,m)={ 
0,
((m%n)+f(n−1,m))%n,
​	
  
n=1
n>1
​	
 

n = 1 时显然成立。接下来分析一下 n > 1 时式子：

执行用时 :
8 ms
, 在所有 C++ 提交中击败了
89.14%
的用户
内存消耗 :
8.7 MB
, 在所有 C++ 提交中击败了
100.00%
的用户
（时间很好，空间完杀!）

上代码：
class Solution {
public:
    int f(int n, int m) {
        if (n == 1) {
            return 0;
        }
        return (m + f(n-1, m)) % n; //在不考虑溢出的情况下，(a%d + c)%d == (a+c)%d
        //return (m%n + f(n-1, m)) % n;
    }
    int lastRemaining(int n, int m) {
        return f(n,m);
    }
};