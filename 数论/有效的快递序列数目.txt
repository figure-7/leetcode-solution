题目难度：HARD

给你 n 笔订单，每笔订单都需要快递服务。

请你统计所有有效的 收件/配送 序列的数目，确保第 i 个物品的配送服务 delivery(i) 总是在其收件服务 pickup(i) 之后。

由于答案可能很大，请返回答案对 10^9 + 7 取余的结果。

 

示例 1：

输入：n = 1
输出：1
解释：只有一种序列 (P1, D1)，物品 1 的配送服务（D1）在物品 1 的收件服务（P1）后。
示例 2：

输入：n = 2
输出：6
解释：所有可能的序列包括：
(P1,P2,D1,D2)，(P1,P2,D2,D1)，(P1,D1,P2,D2)，(P2,P1,D1,D2)，(P2,P1,D2,D1) 和 (P2,D2,P1,D1)。
(P1,D2,P2,D1) 是一个无效的序列，因为物品 2 的收件服务（P2）不应在物品 2 的配送服务（D2）之后。
示例 3：

输入：n = 3
输出：90


提示：

1 <= n <= 500

思路：双周赛第四题，数论（组合学）
首先n个的情况肯定是n-1的情况下插入一对后的情况
即ans = ans * ...
插入分两种情况，一种插入物品不马上取出，即不是连着的：c = 2 * i - 1，c * (c - 1) / 2代表2 * i - 1个空位选两个放置
另一种插入物品马上取出，即是连着的：c = 2 * i - 1，c代表2 * i - 1个空位选一个
原理即dp[i] = 1（i==1）或dp[i - 1] * (2 * i - 1 + C2 2 * i - 1)

上代码：
// P1 D1 1
// * (C_3^2 + C_3^1) * (3 + 3)
// * (C_5^2 + C_5^1) * (15 + 5)
const long long MOD = 1e9 + 7;
class Solution {
public:
    int countOrders(int n) {
        long long ans = 1;
        
        for (int i = 2; i <= n; i++){
            int c = 2 * i - 1;
            ans = ans * (c * (c - 1) / 2 + c) % MOD;
        }
        
        return ans;
    }
};