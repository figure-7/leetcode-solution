题目难度：MEDIUM

列表 arr 由在范围 [1, n] 中的所有整数组成，并按严格递增排序。
请你对 arr 应用下述算法：
从左到右，删除第一个数字，然后每隔一个数字删除一个，直到到达列表末尾。
重复上面的步骤，但这次是从右到左。也就是，删除最右侧的数字，然后剩下的数字每隔一个删除一个。
不断重复这两步，从左到右和从右到左交替进行，直到只剩下一个数字。
给你整数 n ，返回 arr 最后剩下的数字。
示例 1：
输入：n = 9
输出：6
解释：
arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]
arr = [2, 4, 6, 8]
arr = [2, 6]
arr = [6]
示例 2：
输入：n = 1
输出：1
提示：
1 <= n <= 109

思路：数论
接下来上官方题解：
依照题意，我们每次都将整数列表进行间隔删除，因此每次删除后剩余的整数列表都是等差数列。
假设第 k 次删除后的等差数列的首元素为 a 
1
k	
 ，末尾元素为 a 
n
k
 ，公差为 step 
k
 ，元素数目为 cnt 
k
 ，则第 k+1 次删除后的等差数列满足：
step 
k+1
 =step 
k	
 ×2
cnt 
k+1	
 =⌊ 
2
cnt 
k	
 ⌋
初始时 k=0，表示尚未删除任何元素。
如果 k 是偶数，则从左向右删除。
如果元素数目 cnt 
k	
  为奇数，则两端的元素都会被删除。
a 
1
k+1
a 
n
k+1
=a 
1
k	
 +step 
k
=a 
n
k	
 −step 
k
如果元素数目 cnt 
k
  为偶数，则首端元素会被删除，末端元素不会被删除。
a 
1
k+1
a 
n
k+1
=a 
1
k	
 +step 
k
=a 
n
k
如果 k 是奇数，则从右向左删除。
如果元素数目 cnt 
k
  为奇数，则两端的元素都会被删除。
a 
1
k+1
a 
n
k+1 
=a 
1
k	
 +step 
k
=a 
n
k	
 −step 
k
如果元素数目 cnt 
k	
  为偶数，则首端元素不会被删除，末端元素会被删除。
a 
1
k+1
a 
n
k+1
=a 
1
k
=a 
n
k	
 −step 
k
当等差数列只剩一个元素，即 cnt 
k
 =1 时，返回首元素 a 
1
k	
  即可。
注意到末尾元素 a 
n
k	
  可以使用首元素 a_1^ka 
1
k	
 、公差 step 
k	
  和元素数目 cnt 
k	
  表示：
a 
n
k	
 =a 
1
k	
 +step 
k	
 ×(cnt 
k	
 −1)
因此可以省略末尾元素 a_n^ka 
n
k	
 。

执行用时：
4 ms
, 在所有 C++ 提交中击败了
67.69%
的用户
内存消耗：
5.8 MB
, 在所有 C++ 提交中击败了
46.36%
的用户
（时空都一般）

上代码：
class Solution {
public:
    int lastRemaining(int n) {
        int a1 = 1;
        int k = 0, cnt = n, step = 1;
        while (cnt > 1) {
            if (k % 2 == 0) { // 正向
                a1 = a1 + step;
            } else { // 反向
                a1 = (cnt % 2 == 0) ? a1 : a1 + step;
            }
            k++;
            cnt = cnt >> 1;
            step = step << 1;
        }
        return a1;
    }
};