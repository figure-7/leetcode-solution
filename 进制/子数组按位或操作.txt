题目难度：MEDIUM

我们有一个非负整数数组 A。

对于每个（连续的）子数组 B = [A[i], A[i+1], ..., A[j]] （ i <= j），我们对 B 中的每个元素进行按位或操作，获得结果 A[i] | A[i+1] | ... | A[j]。

返回可能结果的数量。 

（多次出现的结果在最终答案中仅计算一次。）

 

示例 1：

输入：[0]
输出：1
解释：
只有一个可能的结果 0 。
示例 2：

输入：[1,1,2]
输出：3
解释：
可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。
产生的结果为 1，1，2，1，3，3 。
有三个唯一值，所以答案是 3 。
示例 3：

输入：[1,2,4]
输出：6
解释：
可能的结果是 1，2，3，4，6，以及 7 。
 

提示：

1 <= A.length <= 50000
0 <= A[i] <= 10^9

思路：进制+哈希表
接下来上题解区题解：
这里只提醒一部分：

\mathcal{Q1}Q1：从头到尾复用，还是从尾到头复用?
\mathcal{Q2}Q2：按位或的性质? 有什么可以帮助你确定复用的顺序？
\mathcal{Q3}Q3：剪枝的条件？ 什么时候确定可以剪枝?
 先回答\mathcal{Q2}Q2,按位或的性质是，积累下去值是永远不会减小的
 再回答\mathcal{Q3}Q3,剪枝是当我们确定计算的单调性或规律性之后，当处于一种临界条件 \rightarrow→ 这条件代表着之后的结果依据规律是肯定无效的时候则剪枝(结合按位或，这就是为啥后面代码中，当我们发现到了某位置我们的值仍然没有变化时，我们会选择剪枝)
 最后回答\mathcal{Q1}Q1:

\boxed{ \begin{aligned} 从前到后: &a &\qquad a | b &\qquad a | b | c \qquad {\small 你会发现，一次遍历后原有的信息都丢了}\\ 从后到前: &a &\qquad & \\ &a|b &\qquad b &\\ &a|b|c &\qquad b|c &\qquad c \qquad {\small 这样所有的信息都保存下来了}\\ \end{aligned}}
从前到后:
从后到前:
​	
  
a
a
a∣b
a∣b∣c
​	
  
a∣b
b
b∣c
​	
  
a∣b∣c你会发现，一次遍历后原有的信息都丢了
c这样所有的信息都保存下来了
​
执行用时 :
884 ms
, 在所有 C++ 提交中击败了
73.57%
的用户
内存消耗 :
89.9 MB
, 在所有 C++ 提交中击败了
100.00%
的用户
（时间不错，空间完杀！）

上代码：
class Solution {
public:
    int subarrayBitwiseORs(vector<int>& A) {
        int N = A.size();
        std::unordered_set<int> S;
        if (N < 2) return N;

        for (int i = 0; i < N; ++ i){
            S.insert(A[i]);
            for (int j = i - 1; j >= 0; -- j){
                if ((A[j] | A[i]) == A[j]) break; // 剪枝
                A[j] |= A[i];
                S.insert(A[j]);
            }
        }

        return S.size();
    }
};