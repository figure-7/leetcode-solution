题目难度：MEDIUM

给你一个整数数组?nums 和一个正整数?threshold ?，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。


请你找出能够使上述结果小于等于阈值?threshold?的除数中 最小 的那个。


每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。


题目保证一定有解。

?



示例 1：

输入：nums = [1,2,5,9], threshold = 6

输出：5

解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。

如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。
如果除数为 5 ，和为 5 (1+1+1+2)。


示例 2：

输入：nums = [2,3,5,7,11], threshold = 11
输出：3


示例 3：

输入：nums = [19], threshold = 5

输出：4
?



提示：

1 <= nums.length <= 5 * 10^4
	1 <= nums[i] <= 10^6
	nums.length <=?threshold <= 10^6



思路：周赛第三题，利用二分方法解，否则超时，我就非得手欠试一下
其实很简单，但是被我写乱套了，先取最大最小的可能值，然后在这之间二分除数即可
运算结果和时绕点弯，整除时不用加一，否则每一项结果要加一
累加和如果小于等于阈值，酒吧区间向左二分，大于就向右二分
遍历结束返回二分的左侧值即可
（边界导乱了，没出来。。而且注意相等时不能直接返回当前的中间值，因为可能会有比中间值小的但是结果与其相同，这点我也没考虑到）

上代码：
class Solution {
public:
    int smallestDivisor(vector<int>& a, int b) {
        int lo = 1, hi = 1000000;
        while(lo<hi) {
            int mid=lo+hi>>1;
            int tmp=0;
            for(int i:a) tmp+=(i+mid-1)/mid;
            if(tmp <= b) hi = mid;
            else lo = mid + 1;
        }
        return lo;
    }
};