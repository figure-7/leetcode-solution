P3371 【模板】单源最短路径（弱化版）

本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过，如有需要请移步 P4779。

题目描述
如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。

输入格式
第一行包含三个整数N、M、S，分别表示点的个数、有向边的个数、出发点的编号。

接下来M行每行包含三个整数Fi、Gi、Wi，分别表示第i条有向边的出发点、目标点和长度。

输出格式
一行，包含N个用空格分隔的整数，其中第i个整数表示从点S出发到点i的最短路径长度（若S=i则最短路径长度为0，若从点S无法到达点i，则最短路径长度为2147483647）

输入输出样例
输入 #1 复制
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4
输出 #1 复制
0 2 4 3
说明/提示
时空限制：1000ms,128M

数据规模：

对于20%的数据：N<=5，M<=15；

对于40%的数据：N<=100，M<=10000；

对于70%的数据：N<=1000，M<=100000；

对于100%的数据：N<=10000，M<=500000。保证数据随机。

对于真正 100% 的数据，请移步 P4779。请注意，该题与本题数据范围略有不同。

思路：首先，处理单源最短路径问题有三种基本方法，由于数据可能存在负边权的问题，三种只有一下这一个题解全过

见洛谷题解：

1.floyd：效率较低，只有70分
具体思路：将所有节点的距离都存在一个数组里，由于要枚举所有的两两组合以及每一个组合的“中转点”，再进行松弛操作

在求单源最短路径的时候就会浪费许多空间，但在求多源最短路时，复杂度仍是O(n^3)使用很广
实测：60分，3TLE，1WA

2.SPFA：考场慎用，在毒瘤数据面前可能退化到O(nm)
具体思路：这里用的是STL队列，首先用数组dis记录起点到每个结点的最短路径，用邻接表来存储图，用vis数组记录当前节点是否在队列中

具体操作为：用队列来保存待优化的结点（类似于BFS），优化时每次取出队首结点，并且用队手节点来对最短路径进行更新并进行松弛操作

如果要对所连点的最短路径需要更新，且改点不在当前的队列中，就将改点加入队列

然后不断进行松弛操作，直至队列空为止。
实测：90分，1WA

3.dijstra的思路很简单，基本上就可以算是一个DP，就是找到与起点距离最短距离一定的点，然后继续往外拓展，更新其它点对于起点的最短距离。
注意：在所有已知距离起点的距离中，最短的那个就是新的起点（因为它距离起点的距离不能再短了）。
将整张图搜完，就大功告成了。
本人还加了一个前向星存边优化（开始直接暴搜，二维存边，只得了10分......）
（前向星是什么东西？看本人以前的题解或网上去查一下就行了），这样就可以进行优化，直达AC！

上代码：
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
using namespace std;
struct Edge//前向星存边
{
    int z;//此边的子节点
    int val;//此边的权值
    int nexty;//与它最近的父节点一样的边的编号
}edge[1000000];
int head[20000];//以某点为父节点引出的最后一条边
int cnt=0;//边编号
inline void add(int a,int b,int c)//存边
{
    cnt++;
    edge[cnt].z=b;
    edge[cnt].val=c;
    edge[cnt].nexty=head[a];
    head[a]=cnt;//更新head
}
int main()
{
    bool visit[20000]={0};//是否作为过起点
    long long dis[20000];//距离
    int n,m,s;
    int a,b,c;
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<=n;i++)dis[i]=2147483647;
    for(int i=0;i<m;i++)
    {
        scanf("%d%d%d",&a,&b,&c);
        add(a,b,c);
    }
    int curr=s;
    dis[s]=0;
    long long minn;
    while(!visit[curr])//即搜完整张图
    {
        visit[curr]=true;//已做为过起点
        for(int i=head[curr];i!=0;i=edge[i].nexty)//链式前向星搜边
        {
            if(!visit[edge[i].z]&&dis[edge[i].z]>dis[curr]+edge[i].val)
            dis[edge[i].z]=dis[curr]+edge[i].val;//更新操作
        }
        minn=2147483647;
        for(int i=1;i<=n;i++)
        {
            if(!visit[i]&&minn>dis[i])//取新的最小值
            {
                minn=dis[i];
                curr=i;
            }
        }
    }
    for(int i=1;i<=n;i++)printf("%lld ",dis[i]);
    return 0;
}