题目难度：MEDIUM

给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。

 

示例 1：

输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
示例 2：

输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。
 

提示：

1 <= A.length <= 20000
0 <= K <= A.length
A[i] 为 0 或 1 

思路：队列+SlidingWindows
先遍历一次数组判断0的个数，小于等于K就返回数组长度（最大为1连续长度为A的数组长度）（WA点1：需要额外讨论）
然后遍历数组，双指针初值都为0，然后滑窗分以下几种情况：
1：A[i] == 0并且K > 0（可以改值），K减一，当前下标入队列
2：A[i] == 0并且K == 0（不可以改值），先取结果和双指针位置差最大值
当前下标进队（WA点2：要先进队，否则有数据可能出现队列为空会空指针调用），头指针改为队首下标，出队一次
3：否则尾指针变为当前下标
外面再去一次最大值
最后返回结果即可

上代码：
class Solution {
public:
    int begin = 0, end = 0, res = 0, sum = 0;
    queue<int> q;
    
    int longestOnes(vector<int>& A, int K) {
        for(int i = 0; i < A.size(); i++)
            if(A[i] == 0)
                sum++;
        if(sum <= K)
            return A.size();
        for(int i = 0; i < A.size(); i++) {
            if(A[i] == 0 && K > 0) {
                K--;
                q.push(i);
            }
            else if(A[i] == 0 && K == 0) {
                res = max(end - begin, res);
                q.push(i);
                begin = q.front();
                q.pop();
            }
            else
                end = i;
        }
        res = max(end - begin, res);
        return res;
    }
};