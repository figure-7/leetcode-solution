题目难度：MEDIUM

在一排树中，第 i 棵树产生 tree[i] 型的水果。
你可以从你选择的任何树开始，然后重复执行以下步骤：

把这棵树上的水果放进你的篮子里。
如果你做不到，就停下来。
移动到当前树右侧的下一棵树。
如果右边没有树，就停下来。
请注意，在选择一颗树后，你没有任何选择：
你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。

你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。
用这个程序你能收集的水果总量是多少？

 

示例 1：

输入：[1,2,1]
输出：3
解释：我们可以收集 [1,2,1]。
示例 2：

输入：[0,1,2,2]
输出：3
解释：我们可以收集 [1,2,2].
如果我们从第一棵树开始，我们将只能收集到 [0, 1]。
示例 3：

输入：[1,2,3,2,2]
输出：4
解释：我们可以收集 [2,3,2,2].
如果我们从第一棵树开始，我们将只能收集到 [1, 2]。
示例 4：

输入：[3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：我们可以收集 [1,2,1,1,2].
如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 个水果。
 

提示：

1 <= tree.length <= 40000
0 <= tree[i] < tree.length

思路：SlidingWindows
（WA点1,2：方法不对）
保存每两个不同值进数组，个数为数组对应值
然后先取两个不同的数组计算，然后后双指针对应区间下标
之后从后后面遍历结束，每次遇见不同值先取窗口长度与结果（初值0）的最大值
然后就缩短左侧指针直到胜两个值为止（利用数组），数组对应值为0即可
然后数组加上当前下标值，值为1，（WA点3：少了这一步导致某些样例结果过大）右侧窗口有当前下标一致即可
否则数组计数，移动右指针
最后再去一遍窗口最大值返回即可

执行用时 :
252 ms
, 在所有 C++ 提交中击败了
34.88%
的用户
内存消耗 :
52.2 MB
, 在所有 C++ 提交中击败了
100.00%
的用户
（时间不咋地，空间完杀！）

上代码：
class Solution {
public:
    int begin = 0, end = 0, b = 0, res = 0;
    int curr[40005] = {0};
    
    int totalFruit(vector<int>& tree) {
        int a = tree[0];
        curr[a]++;
        for(int i = 1; i < tree.size(); i++) {
            if(a != tree[i]) {
                b = tree[i];
                end = i;
                curr[b]++;
                break;
            } else curr[a]++;
        }
        for(int i = end + 1; i < tree.size(); i++) {
            if(tree[i] != a && tree[i] != b) {
                res = max(res, end - begin + 1);
                int cur = begin;
                while(curr[a] != 0 && curr[b] != 0) {
                    curr[tree[cur]]--;
                    cur++;
                }
                begin = cur;
                curr[tree[i]]++;
                if(curr[a] == 0) a = tree[i];
                else b = tree[i];
                end = i;
            } else {
                curr[tree[i]]++;
                end = i;
            }
        }
        res = max(res, end - begin + 1);
        return res;
    }
};