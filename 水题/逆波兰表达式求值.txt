题目难度：MEDIUM

根据逆波兰表示法，求表达式的值。


有效的运算符包括?+,?-,?*,?/?。
每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。
换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。


示例?1：

输入: ["2", "1", "+", "3", "*"]

输出: 9

解释: ((2 + 1) * 3) = 9


示例?2：

输入: ["4", "13", "5", "/", "+"]

输出: 6

解释: (4 + (13 / 5)) = 6


示例?3：

输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]

输出: 22

解释: 
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22



思路：利用栈即可，倒这来，遇见运算符就取出两个值计算结果，结果入栈
不是运算符就直接保存栈里
最后返回即可

执行用时 :
16 ms
, 在所有 C++ 提交中击败了
91.45%
的用户
内存消耗 :
11.6 MB
, 在所有 C++ 提交中击败了
23.86%
的用户

上代码：（我的字符串转换出了问题仅击败5的，所以换了别人的，，）
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> numbers;
        for(int i = 0 ; i < tokens.size() ;++i){
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/"){
                int res;
                int n2 = numbers.top();
                numbers.pop();
                int n1 = numbers.top();
                numbers.pop();
                
                if(tokens[i] == "+")
                   res = n1 + n2;
                else if(tokens[i] == "-")
                   res = n1 - n2;
                else if(tokens[i] == "/")
                   res = n1 / n2;
                else
                   res = n1 * n2;
                numbers.push(res);
            }else{
                numbers.push(stoi(tokens[i]));
            } 
        }
        return numbers.top();
    }
};