

给定一个?m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。
请使用原地算法。



示例?1:


输入: 
[
? [1,1,1],
? [1,0,1],
? [1,1,1]
]

输出: 
[
? [1,0,1],
? [0,0,0],
? [1,0,1]
]


示例?2:


输入: 
[
? [0,1,2,0],
? [3,4,5,2],
? [1,3,1,5]
]

输出: 
[
? [0,0,0,0],
? [0,4,5,0],
? [0,3,1,0]
]


进阶:



一个直接的解决方案是使用 ?O(mn)?的额外空间，但这并不是一个好的解决方案。

一个简单的改进方案是使用 O(m?+?n) 的额外空间，但这仍然不是最好的解决方案。

你能想出一个常数空间的解决方案吗？


执行用时 :
72 ms
, 在所有 C++ 提交中击败了
84.30%
的用户
内存消耗 :
11.7 MB
, 在所有 C++ 提交中击败了
9.68%
的用户
（空间就击败了这些？！！抱歉这是垃圾算法）

思路：这题我常数空间没有想出来，但是实现了O(m+n)空间的算法，就是把横纵坐标分别放入一维数组中
然后修改的时候两个两个取，对数组做变换即可。

上（垃圾）代码：
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        vector<int> curr;
        for(int i = 0; i < matrix.size(); i++) {
            for(int j = 0; j < matrix[0].size(); j++) {
                if(matrix[i][j] == 0) {
                    curr.push_back(i);
                    curr.push_back(j);
                }
            }
        }
        for(int i = 0; i < curr.size(); i = i + 2) {
            for(int j = 0; j < matrix.size(); j++) {
                matrix[j][curr[i+1]] = 0;
            }
            for(int k = 0; k < matrix[0].size(); k++) {
                matrix[curr[i]][k] = 0;
            }
        }
    }
};