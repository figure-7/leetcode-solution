题目难度：MEDIUM

给你一个以二进制形式表示的数字 s 。

请你返回按下述规则将其减少到 1 所需要的步骤数：

如果当前数字为偶数，则将其除以 2 。

如果当前数字为奇数，则将其加上 1 。

题目保证你总是可以按上述规则将测试用例变为 1 。

 

示例 1：

输入：s = "1101"
输出：6
解释："1101" 表示十进制数 13 。
Step 1) 13 是奇数，加 1 得到 14 
Step 2) 14 是偶数，除 2 得到 7
Step 3) 7  是奇数，加 1 得到 8
Step 4) 8  是偶数，除 2 得到 4  
Step 5) 4  是偶数，除 2 得到 2 
Step 6) 2  是偶数，除 2 得到 1  
示例 2：

输入：s = "10"
输出：1
解释："10" 表示十进制数 2 。
Step 1) 2 是偶数，除 2 得到 1 
示例 3：

输入：s = "1"
输出：0
 

提示：

1 <= s.length <= 500
s 由字符 '0' 或 '1' 组成。
s[0] == '1'

思路：周赛第二题（17min46s），进制
依题意，可以得到方法：
逆序遍历字符串
只要对应二进制末尾位为0，就直接去掉最后一位，次数加一（执行除二操作（因为是偶数））
否则如果下标为0退出循环
否则将当前位置字符置'0'
然后找到前面不为'0'的置1，期间所有字符'1'置0
如果全是'1'，那么就再都变'0'后再字符串最前面补一个'1'，次数加一（执行加一操作（因为是奇数））
直到字符串遍历结束返回次数即可

上代码：
class Solution {
public:
    int res = 0;
    
    int numSteps(string s) {
        for(int i = s.size() - 1; i >= 0; i--) {
            cout<<s<<endl;
            if(s[i] == '0') {
                s = s.substr(0, s.size() - 1);
                res++;
            } else {
                if(i == 0) break;
                s[i] = '0';
                int j = i - 1;
                while(j >= 0 && s[j] == '1') {
                    s[j] = '0';
                    j--;
                }
                res++;
                if(j == -1) {
                    s = '1' + s;
                    i += 2;
                }
                else {
                    s[j] = '1';
                    i++;
                }
            }
        }
        return res;
    }
};