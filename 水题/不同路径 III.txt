题目难度：HARD

在二维网格 grid 上，有 4 种类型的方格：

1 表示起始方格。且只有一个起始方格。
2 表示结束方格，且只有一个结束方格。
0 表示我们可以走过的空方格。
-1 表示我们无法跨越的障碍。
返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。

 

示例 1：

输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
输出：2
解释：我们有以下两条路径：
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
示例 2：

输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
输出：4
解释：我们有以下四条路径： 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
示例 3：

输入：[[0,1],[2,0]]
输出：0
解释：
没有一条路能完全穿过每一个空的方格一次。
请注意，起始和结束方格可以位于网格中的任意位置。
 

提示：

1 <= grid.length * grid[0].length <= 20

思路：BFS
先统计出数组中0和2的个数和，并标记1的位置，然后带入BFS四象封印，套板子
把布尔数组改为内部数组，判重改为BFS中循环外边该值即可（因为每种路径情况不一样，不能全局去重）
当找到2时，如果路径走过个数和次结果加一结束BFS，否则直接结束BFS
最后返回结果即可

执行用时 :
460 ms
, 在所有 C++ 提交中击败了
8.36%
的用户
内存消耗 :
69.4 MB
, 在所有 C++ 提交中击败了
6.17%
的用户
（时空都炸了...）

上代码：
class Solution {
public:
    int cnt = 0, a = 0, b = 0, res = 0;
    int dict[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    
    void BFS(int x, int y, vector<vector<int> > grid, vector<vector<bool> > flag, int sum) {
        flag[x][y] = true;
        if(grid[x][y] == 2) {
            cout<<sum<<cnt<<endl;
            if(sum == cnt) {
                res++;
                return ;
            }
            else
                return ;
        }
        for(int i = 0; i < 4; i++) {
            int xx = x + dict[i][0];
            int yy = y + dict[i][1];
            if(xx >= 0 && yy >= 0 && xx < grid.size() && yy < grid[0].size() && grid[xx][yy] != -1 && !flag[xx][yy])
                BFS(xx, yy, grid, flag, sum + 1);
        }
    }
    
    int uniquePathsIII(vector<vector<int>>& grid) {
        vector<vector<bool> > f(25, vector<bool>(25, false));
        for(int i = 0; i < grid.size(); i++) {
            for(int j = 0; j < grid[i].size(); j++) {
                if(grid[i][j] == 0 || grid[i][j] == 2)
                    cnt++;
                if(grid[i][j] == 1) {
                    a = i;
                    b = j;
                }
            }
        }
        BFS(a, b, grid, f, 0);
        return res;
    }
};