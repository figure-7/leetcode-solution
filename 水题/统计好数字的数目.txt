题目难度：MEDIUM

我们称一个数字字符串是 好数字 当它满足（下标从 0 开始）偶数 下标处的数字为 偶数 且 奇数 下标处的数字为 质数 （2，3，5 或 7）。
比方说，"2582" 是好数字，因为偶数下标处的数字（2 和 8）是偶数且奇数下标处的数字（5 和 2）为质数。
但 "3245" 不是 好数字，因为 3 在偶数下标处但不是偶数。
给你一个整数 n ，请你返回长度为 n 且为好数字的数字字符串 总数 。
由于答案可能会很大，请你将它对 109 + 7 取余后返回 。
一个 数字字符串 是每一位都由 0 到 9 组成的字符串，且可能包含前导 0 。
示例 1：
输入：n = 1
输出：5
解释：长度为 1 的好数字包括 "0"，"2"，"4"，"6"，"8" 。
示例 2：
输入：n = 4
输出：400
示例 3：
输入：n = 50
输出：564908303
提示：
1 <= n <= 1015

思路：周赛第三题（43min44s），高精度
（TLE点1：遍历后超时）
（WA点1，2，3：算法错误）
需要进行两次剪枝，一次是除以10000000000，这样保证结果小于10的5次幂
遍历结果并且把结果值（初值1）乘以结果次的176203868（也就是10000000000下取余后的好数字数），每次遍历都要取余数
第二次是除以100000，这样保证结果小于10的5次幂（TLE点2：没有这第二步剪枝，剪枝后依旧超时）
遍历结果并且把结果值乘以结果次的86331955（也就是100000下取余后的好数字数），每次遍历都要取余数
上面因为是累乘，顺序结果都一样，所以可直接这样计算
最后结果余100000，这样保证结果小于10的5次幂
遍历结果并且把结果值分别乘以5和4，根据布尔值进行变换，要先乘以5，再乘以4，每次遍历都要取余数
最后返回结果值的int类型即可

上代码：
class Solution {
public:
    bool flag = false;
    long long res = 1;
    
    int countGoodNumbers(long long n) {
        long long cur = n / 10000000000;
        while(cur > 0) {
            res *= 176203868;
            cur--;
            res %= 1000000007;
        }
        n %= 10000000000;
        long long aim = n / 100000;
        while(aim > 0) {
            res *= 86331955;
            aim--;
            res %= 1000000007;
        }
        long long sum = n % 100000;
        for(int i = 0; i < sum; i++) {
            if(flag) {
                res *= 4;
                flag = false;
            } else {
                res *= 5;
                flag = true;
            }
            res %= 1000000007;
        }
        return (int)res;
    }
};