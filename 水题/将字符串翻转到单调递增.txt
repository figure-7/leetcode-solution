题目难度：MEDIUM

如果一个由 '0' 和 '1' 组成的字符串，是以一些 '0'（可能没有 '0'）后面跟着一些 '1'（也可能没有 '1'）的形式组成的，那么该字符串是单调递增的。

我们给出一个由字符 '0' 和 '1' 组成的字符串 S，我们可以将任何 '0' 翻转为 '1' 或者将 '1' 翻转为 '0'。

返回使 S 单调递增的最小翻转次数。

 

示例 1：

输入："00110"
输出：1
解释：我们翻转最后一位得到 00111.
示例 2：

输入："010110"
输出：2
解释：我们翻转得到 011111，或者是 000111。
示例 3：

输入："00011000"
输出：2
解释：我们翻转得到 00000000。
 

提示：

1 <= S.length <= 20000
S 中只包含字符 '0' 和 '1'

思路：贪心
先逆序遍历字符串看后面有多少个'1'，把之后所有遍历的结束指针指定再当前不是字符'1'的位置（WA点1：后面为'1'无需更换，额外排除）
然后如果字符位置到下标0了，最后一位可能是'0'，而前面可能有'1'，所以要再赋值为数组长度
之后从头遍历，遇见字符'1'开始累计'1'和'0'的个数
当是字符'1'并且之前'0'的个数要大于'1'就把结果（初值0）加'1'的个数（WA点2：贪心，每个区间取最优才是最优结果）
然后个数都赋值0（前面已经改好）并且接下来遍历开始从当前位置开始（WA点3：没有从当前位置开始）
之后在遍历一次，遇见'1'开始累积'1'和'0'的个数
最后取最小的返回三目运算符加给结果即可

上代码：
class Solution {
public:
    int a = 0, b = 0, cur = 0, res = 0, begin = 0;
    bool flag = false;
    
    int minFlipsMonoIncr(string S) {
        for(int i = S.size() - 1; i >= 0; i--) {
            if(S[i] == '1') cur = i;
            else break;
        }
        if(cur == 0) cur = S.size();
        for(int i = 0; i < cur; i++) {
            if(S[i] == '1') {
                if(b > a) {
                    res += a;
                    a = 0;
                    b = 0;
                    begin = i;
                }
                flag = true;
                a++;
            }
            else if(flag) b++;
        }
        a = 0;
        b = 0;
        flag = false;
        for(int i = begin; i < cur; i++) {
            if(S[i] == '1') {
                flag = true;
                a++;
            }
            else if(flag) b++;
        }
        return a > b ? res + b : res + a;
    }
};