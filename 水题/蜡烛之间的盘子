题目难度：MEDIUM

给你一个长桌子，桌子上盘子和蜡烛排成一列。
给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。
同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti...righti] （包含左右端点的字符）。
对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。
如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。
比方说，s = "||**||**|*" ，查询 [3, 8] ，表示的是子字符串 "*||**|" 。
子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。
请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。
示例 1:
输入：s = "**|**|***|", queries = [[2,5],[5,9]]
输出：[2,3]
解释：
- queries[0] 有两个盘子在蜡烛之间。
- queries[1] 有三个盘子在蜡烛之间。
示例 2:
输入：s = "***|**|*****|**||**|*", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
输出：[9,0,0,0,0]
解释：
- queries[0] 有 9 个盘子在蜡烛之间。
- 另一个查询没有盘子在蜡烛之间。
提示：
3 <= s.length <= 105
s 只包含字符 '*' 和 '|' 。
1 <= queries.length <= 105
queries[i].length == 2
0 <= lefti <= righti < s.length

思路：前缀和
首先初始化下标值为字符串长度减一，从后向前循环直到循环结束或者字符串当前字符为|
之后从当前下标值开始遍历到第一项，如果当前字符串字符不为|，先把累计值（初值0）给左侧数组（初始化值都为0），累计值再加一
否则累计值变为0（这里是为了处理**|**|**|*在【3，9】（**|**|*）时左侧的两个*都不能算在内的情况，即9的前缀和减去8的前缀和在减去左侧数组对应3下标的值）
之后下标值清零，累计值清零
当下标值小于字符串长度时，左侧数组下标对应值清零（这里是为了处理**|**|**|*在【3，9】（**|**|*）时左侧下标为1和2时本身前缀和就为0，不能重复减）
如果字符串当前字符为|，结束循环
从当前下标值开始遍历到字符串结束，如果字符串当前字符不为|
累加值（初值0）加一，累计值加一，累加值给建立数组（初始化值都为0），累计值给右侧数组（初始化值都为0）
否则累计值清零，累加值给建立数组
（建立数组用来保存前缀和，同时为了处理**|**|**|*在【3，9】（**|**|*）时右侧的一个*不能算在内的情况，即9的前缀和减去8的前缀和在减去左侧数组对应3下标的值在前去右侧数组对应9下标的值）
遍历给定数组，每次取当前遍历下标对应数组第二项对应下标的建立数组值减去当前遍历下标对应数组第二项对应下标的右侧数组值减去当前遍历下标对应数组第一项对应下标的左侧数组值减去当前遍历下标对应数组第一项对应下标的建立数组值
如果结果小于等于0就把0存进结果数组（不能存在小于0的情况）
否则就把结果存进结果数组中
最后返回结果数组即可

执行用时：
448 ms
, 在所有 C++ 提交中击败了
23.43%
的用户
内存消耗：
143.4 MB
, 在所有 C++ 提交中击败了
21.15%
的用户
（时空都不咋地）

上代码：
class Solution {
public:
    int sum = 0, num = 0;
    vector<int> res;

    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {
        cout<<s.size()<<endl;
        vector<int> curr(s.size(), 0), aim(s.size(), 0), vec(s.size(), 0);
        int siz = s.size();
        while(siz >= 0) {
            if(s[siz] == '|') break;
            siz--;
        }
        for(int i = siz; i >= 0; i--) {
            if(s[i] != '|') {
                vec[i] = num;
                num++;
            } else num = 0;
        }
        num = 0;
        siz = 0;
        while(siz < s.size()) {
            vec[siz] = 0;
            if(s[siz] == '|') break;
            else siz++;
        }
        for(int i = siz; i < s.size(); i++) {
            if(s[i] != '|') {
                sum++;
                num++;
                curr[i] = sum;
                aim[i] = num;
            } else {
                num = 0;
                curr[i] = sum;
            }
        }
        for(int i = 0; i < queries.size(); i++) {
            int cur = curr[queries[i][1]] - curr[queries[i][0]] - aim[queries[i][1]] - vec[queries[i][0]];
            if(cur <= 0) res.push_back(0);
            else res.push_back(cur);
        }
        return res;
    }
};
