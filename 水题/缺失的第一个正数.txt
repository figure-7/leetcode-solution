题目难度：HARD

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例 1:

输入: [1,2,0]
输出: 3
示例 2:

输入: [3,4,-1,1]
输出: 2
示例 3:

输入: [7,8,9,11,12]
输出: 1
说明:

你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

思路：首先时间O(N)，一次遍历，通过变遍历边从1开始查找，每次查找值加一，最后返回查找值实现
      时间直接击败100整。
      然后空间O(1)，我用了一下排序函数，空间严格讲好像不是O(1)，但是得却击败不少人的空间
      也没有用到哈希表查找。

执行用时 :
0 ms
, 在所有 C++ 提交中击败了
100.00%
的用户
内存消耗 :
8.6 MB
, 在所有 C++ 提交中击败了
85.48%
的用户

上代码：
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int sum = 1;
        if(nums.size() == 0) {
            return 1;
        }
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size(); i++) {
            if(sum == nums[i]) {
                sum++;
            }
        }
        return sum;
    }
};