题目难度：EASY

在一个 8 x 8 的棋盘上，有一个白色车（rook）。

也可能有空方块，白色的象（bishop）和黑色的卒（pawn）。

它们分别以字符 “R”，“.”，“B” 和 “p” 给出。

大写字符表示白棋，小写字符表示黑棋。

车按国际象棋中的规则移动：

它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒。

另外，车不能与其他友方（白色）象进入同一个方格。

返回车能够在一次移动中捕获到的卒的数量。
 

示例 1：



输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","R",".",".",".","p"],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释：
在本例中，车能够捕获所有的卒。
示例 2：



输入：[[".",".",".",".",".",".",".","."],[".","p","p","p","p","p",".","."],[".","p","p","B","p","p",".","."],[".","p","B","R","B","p",".","."],[".","p","p","B","p","p",".","."],[".","p","p","p","p","p",".","."],[".",".",".",".",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：0
解释：
象阻止了车捕获任何卒。
示例 3：



输入：[[".",".",".",".",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".","p",".",".",".","."],["p","p",".","R",".","p","B","."],[".",".",".",".",".",".",".","."],[".",".",".","B",".",".",".","."],[".",".",".","p",".",".",".","."],[".",".",".",".",".",".",".","."]]
输出：3
解释： 
车可以捕获位置 b5，d6 和 f5 的卒。

思路：BFS
遍历二维数组，先找到车的位置，记录下标
然后遍历四次，四个方向先遇到象就结束循环（被拦截），先遇到兵就结果加一，否则继续
最后返回结果即可

执行用时 :
0 ms
, 在所有 C++ 提交中击败了
100.00%
的用户
内存消耗 :
8.7 MB
, 在所有 C++ 提交中击败了
5.26%
的用户
（时间完杀！！！空间炸了（依旧是原地...））

上代码：
class Solution {
public:
    int res = 0, a = 0, b = 0;
    
    int numRookCaptures(vector<vector<char>>& board) {
        for(int i = 0; i < 8; i++) {
            for(int j = 0; j < 8; j++) {
                if(board[i][j] == 'R') {
                    a = i;
                    b = j;
                }
            }
        }
        for(int i = a + 1; i < 8; i++) {
            if(board[i][b] == 'B')
                break;
            if(board[i][b] == 'p') {
                res++;
                break;
            }
        }
        for(int i = b + 1; i < 8; i++) {
            if(board[a][i] == 'B')
                break;
            if(board[a][i] == 'p') {
                res++;
                break;
            }
        }
        for(int i = b - 1; i >= 0; i--) {
            if(board[a][i] == 'B')
                break;
            if(board[a][i] == 'p') {
                res++;
                break;
            }
        }
        for(int i = a - 1; i >= 0; i--) {
            if(board[i][b] == 'B')
                break;
            if(board[i][b] == 'p') {
                res++;
                break;
            }
        }
        return res;
    }
};