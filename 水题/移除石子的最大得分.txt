题目难度：MEDIUM

你正在玩一个单人游戏，面前放置着大小分别为 a​​​​​​、b 和 c​​​​​​ 的 三堆 石子。
每回合你都要从两个 不同的非空堆 中取出一颗石子，并在得分上加 1 分。
当存在 两个或更多 的空堆时，游戏停止。
给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。
示例 1：
输入：a = 2, b = 4, c = 6
输出：6
解释：石子起始状态是 (2, 4, 6) ，最优的一组操作是：
- 从第一和第三堆取，石子状态现在是 (1, 4, 5)
- 从第一和第三堆取，石子状态现在是 (0, 4, 4)
- 从第二和第三堆取，石子状态现在是 (0, 3, 3)
- 从第二和第三堆取，石子状态现在是 (0, 2, 2)
- 从第二和第三堆取，石子状态现在是 (0, 1, 1)
- 从第二和第三堆取，石子状态现在是 (0, 0, 0)
总分：6 分 。
示例 2：
输入：a = 4, b = 4, c = 6
输出：7
解释：石子起始状态是 (4, 4, 6) ，最优的一组操作是：
- 从第一和第二堆取，石子状态现在是 (3, 3, 6)
- 从第一和第三堆取，石子状态现在是 (2, 3, 5)
- 从第一和第三堆取，石子状态现在是 (1, 3, 4)
- 从第一和第三堆取，石子状态现在是 (0, 3, 3)
- 从第二和第三堆取，石子状态现在是 (0, 2, 2)
- 从第二和第三堆取，石子状态现在是 (0, 1, 1)
- 从第二和第三堆取，石子状态现在是 (0, 0, 0)
总分：7 分 。
示例 3：
输入：a = 1, b = 8, c = 8
输出：8
解释：最优的一组操作是连续从第二和第三堆取 8 回合，直到将它们取空。
注意，由于第二和第三堆已经空了，游戏结束，不能继续从第一堆中取石子。
提示：
1 <= a, b, c <= 105

思路：周赛第二题，排序
（TLE点，暴力每次都排序）
将三个数字放入数组并排序，然后取前两者的差值取匹配最大值（为了让前两个值相等便于比较）
结果值（初值0）加上差值，后两项减去差值（这样前两项值相等）
然后取前两项的和与最后一项做比较，结果值累加差值
如果前两项的和大于最后一项，那么和值减去最后一项的值（前两项剩下的再匹配），然后结果值加上和值除二
否则什么都不做（因为最后一项值是在太大了，前两项都匹配完了，无法再匹配）
返回结果值即可

上代码：
class Solution {
public:
    vector<int> curr;
    int res = 0;
    
    int maximumScore(int a, int b, int c) {
        curr.push_back(a);
        curr.push_back(b);
        curr.push_back(c);
        sort(curr.begin(), curr.end());
        int cur = curr[1] - curr[0];
        curr[2] -= cur;
        curr[1] -= cur;
        res += cur;
        int sum = curr[0] + curr[1];
        res += min(sum, curr[2]);
        if(sum >= curr[2]) {
            sum -= curr[2];
            int aim = sum / 2;
            res += aim;
        }
        return res;
    }
};