题目难度：MEIDUM

根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。

如果之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。

每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

思路：栈
这题要不是栈的专项我可能还不会写，感觉没省下太多时间，，，
设立两个数组，一个用来当栈使，保存下标的值以便计算差值，另一个做结果数组保存差值，长度初始化为原数组长度
先将0下标放入栈中，每次比较栈顶跟当前元素大小，分两种情况：
1：当前值大于栈顶元素下标对应的值，遍历栈进行判断，对应栈顶下标的结果数组值即为当前遍历下标值与栈顶值的差
然后栈顶出栈，直至循环结束把当前下标进栈
2：当前值小于等于栈顶元素下标对应的值，直接把当前下标进栈即可
最后根据给定数组长度与结果数组长度差值遍历给结果数组后面填0，最后返回即可

执行用时 :
224 ms
, 在所有 cpp 提交中击败了
90.69%
的用户
内存消耗 :
15.9 MB
, 在所有 cpp 提交中击败了
73.46%
的用户
（时间很好，空间也不错，，，栈厉害啊~）

上代码：
class Solution {
public:
    vector<int> curr;
    
    vector<int> dailyTemperatures(vector<int>& T) {
        int len = T.size();
        vector<int> res(len);
        if(T.size() == 0) return res;
        curr.push_back(0);
        for(int i = 1; i < T.size(); i++) {
            while(curr.size() != 0 && T[i] > T[curr.back()]) {
                res[curr.back()] = i - curr.back();
                curr.pop_back();
            }
            curr.push_back(i);
        }
        while(res.size() < T.size())
            res.push_back(0);
        return res;
    }
};