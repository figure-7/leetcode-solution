题目难度：MEDIUM

给定一个数组 A，将其划分为两个不相交（没有公共元素）的连续子数组 left 和 right， 使得：

left 中的每个元素都小于或等于 right 中的每个元素。
left 和 right 都是非空的。
left 要尽可能小。
在完成这样的分组后返回 left 的长度。可以保证存在这样的划分方法。

 

示例 1：

输入：[5,0,3,8,6]
输出：3
解释：left = [5,0,3]，right = [8,6]
示例 2：

输入：[1,1,1,0,6,12]
输出：4
解释：left = [1,1,1,0]，right = [6,12]
 

提示：

2 <= A.length <= 30000
0 <= A[i] <= 10^6
可以保证至少有一种方法能够按题目所描述的那样对 A 进行划分。

思路：模拟
（WA点1,2：使用了错误的方法）
初始化最大值和中间变量值为数组第一个元素值，结果值0
遍历数组，每次更新最大值，当数组当前元素小于中间变量值时，当前下标给结果
如果最大值大于中间变量值（代表中间有更大的值），就把最大值给中间变量
遍历结束后返回结果加一即可

执行用时 :
64 ms
, 在所有 C++ 提交中击败了
34.56%
的用户
内存消耗 :
19.8 MB
, 在所有 C++ 提交中击败了
50.00%
的用户
（时间不咋地，空间一般）

上代码：
class Solution {
public:
    int partitionDisjoint(vector<int>& A) {
        int cur = A[0], res = 0, bigger = A[0];
        for(int i = 1; i < A.size(); i++) {
            bigger = max(bigger, A[i]);
            if(A[i] < cur) {
                res = i;
                if (cur < bigger) cur = bigger;
            }
        }
        return res + 1;
    }
};