题目难度：MEDIUM

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。

假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头最小的可能重量。
如果没有石头剩下，就返回 0。

 

示例：

输入：[2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
 

提示：

1 <= stones.length <= 30
1 <= stones[i] <= 1000

思路：DP
接下来上题解区题解：
无

执行用时 :
12 ms
, 在所有 C++ 提交中击败了
20.63%
的用户
内存消耗 :
10.4 MB
, 在所有 C++ 提交中击败了
5.19%
的用户
（时间不咋地，空间炸了）

上代码：
class Solution {
public:
    // 因为挑选石头是任意的, 不能使用贪心法每次挑选重量最大的两块石头
    // 第一次挑选a,b, 放回a-b, ....., 第n次挑选c,a-b, 放回c-a+b， 最终结果为(a+d+c+g)-(b+e+f)
    // 因此, 可以视作一个0-1背包问题，将石头分为两堆，两堆重量之差最小是多少
    // 背包容量为 sum/2， 每个石头拿起来或者不拿起来，能装下最多的石头重量是多少
    int lastStoneWeightII(vector<int> &stones){
        int sum = accumulate(stones.begin(), stones.end(), 0);
        vector<bool> dp(sum / 2 + 1, false);    // dp[i] - 是否可以找到一部分石头，其总重量为i
        dp[0] = true;                           // dp[0] - 不拿石头时，其总重量为0

        for(int i = 0; i < stones.size(); ++i)
            for(int w = dp.size() - 1; w >= stones[i]; --w)
                dp[w] = dp[w] | dp[w - stones[i]];

        // 找到可以放的最大重量假设为i, 则两部分的差值为 (sum - i) - i
        for(int i = dp.size() - 1; i >= 0; --i)
            if(dp[i] == true)
                return sum - 2 * i;

        return sum;
    }
};