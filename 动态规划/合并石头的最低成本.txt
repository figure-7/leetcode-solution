题目难度：HARD

有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。

每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。

找出把所有石头合并成一堆的最低成本。

如果不可能，返回 -1 。

 

示例 1：

输入：stones = [3,2,4,1], K = 2
输出：20
解释：
从 [3, 2, 4, 1] 开始。
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
合并 [4, 1]，成本为 5，剩下 [5, 5]。
合并 [5, 5]，成本为 10，剩下 [10]。
总成本 20，这是可能的最小值。
示例 2：

输入：stones = [3,2,4,1], K = 3
输出：-1
解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。
所以这项任务是不可能完成的。.
示例 3：

输入：stones = [3,5,1,2,6], K = 3
输出：25
解释：
从 [3, 5, 1, 2, 6] 开始。
合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。
合并 [3, 8, 6]，成本为 17，剩下 [17]。
总成本 25，这是可能的最小值。
 

提示：

1 <= stones.length <= 30
2 <= K <= 30
1 <= stones[i] <= 100

思路：DP
接下来上题解区题解：
总体思路是戳气球（hot100，https://leetcode-cn.com/problems/burst-balloons/）的升级版。
dp [i] [j]表示将范围为第i〜j堆的石头经过尽可能多的步骤合并后的最小成本（直到我们无法进一步合并）。
因此，对于第i〜j堆的石头，合并后将保留（j-i）％（K-1）+ 1 个堆。
例如，当我们将[...，3、4、5、6，...]从第2堆合并到第5堆，且K = 3时，我们将留下2个堆[12，6]，其成本为12。
我们考虑合并更大范围的石头堆时，策略是将总的范围分成左、右两部分，尽可能多地合并左侧部分（直到我们无法进一步合并），并且将右侧部分合并为1个堆（右侧部分的长度应有限制，即右侧部分的长度是K-1的整数倍+1），然后将两个部分的成本相加，最后检查是否可以合并两个部分目前剩余的石头堆，如果可以合并再把这一合并成本加进来。
两个部分剩余石头堆能够合并的条件是有限的，即（r-l）是（K-1）的整数倍。
具体而言，我们让右侧的部分p〜r合并为1堆，并让左侧的l〜p-1尽可能多地合并。
这样，我们以p为pivot将l〜r合并（合并后右侧剩余1个堆，左侧剩余的堆数不超过K-1）。
在大多数情况下，我们已经完成了l〜r的合并。
除非当l〜p-1可以合并为K-1个堆，此时，我们需要进行额外的合并，也就是将左侧K-1堆与右侧1堆合并。
上面提到额外的合并，将花费l～r范围内所有石头的总和。

执行用时 :
4 ms
, 在所有 C++ 提交中击败了
93.68%
的用户
内存消耗 :
10.4 MB
, 在所有 C++ 提交中击败了
22.73%
的用户
（时间很好，空间不咋地）

上代码：
class Solution {
public:
    int mergeStones(vector<int>& stones, int K) {
        int n=stones.size();
        if(n<=1) return 0;
        if((n-1)%(K-1)) return -1;
        //计算前缀总和以备后用
        //prefixSum[i]代表第0～i-1堆的石头数目之和。
        int prefixSum[n+1]={0}; 
        for(int i=1;i<=n;++i) prefixSum[i]=prefixSum[i-1]+stones[i-1]; 
        //dp[i][j]代表从第i堆到第j堆合并的成本
        int dp[n][n]; 
        for(int i=0;i<n;++i)
        for(int j=0;j<n;++j)
            dp[i][j]=0;
        for(int r=0;r<n;++r) {
            for(int l=r-K+1;l>=0;--l) { //l>r-K+1的这部分由于不足K堆无法合并，可以跳过不考虑
                int minNum=INT_MAX;
                //以p为pivot，将l～r分成两部分：l～p-1，p～r。
                //左侧部分l～p-1不一定能够合并成一堆，这里p需要保证的是右侧部分p～r一定可以合并成一堆。
                //将两部分l～p-1，p～r预合并，暂不加上两部分合并的成本，下面单独判断两部分的合并条件。
                for(int p=r;p>l;p-=(K-1)) { 
                    minNum=min(minNum, dp[l][p-1]+dp[p][r]); 
                }
                dp[l][r]=minNum; 

                //l～r不一定满足可以合并的关系：（r-l）是（K-1）的整数倍。
                //所以需要判断每当满足这一条件则合并两部分，加上合并成本；否则暂不合并，避免合并成本的重复计算。
                if((r-l)%(K-1)==0) dp[l][r]+=(prefixSum[r+1]-prefixSum[l]); 
            }
        }
        return dp[0][n-1];
    }
};