题目难度：HARD

给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。

逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i < j且 a[i] > a[j]，则其为一个逆序对；否则不是。

由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。

示例 1:

输入: n = 3, k = 0
输出: 1
解释: 
只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
示例 2:

输入: n = 3, k = 1
输出: 2
解释: 
数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。
说明:

 n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。

思路：DP
接下来上题解区思路：

设 f(i, j)f(i,j) 表示前 ii 个数构成 jj 个逆序对的方案数目。

如果算出来了前 i-1i−1 的答案，考虑把元素 ii 插入到原来的序列里，插的位置不同会产生不同的逆序对数目。

增加的逆序对数在 [0, i-1][0,i−1] 内，据此可以写出状态转移方程：

f(i, j) = \sum_{k = 0}^{i - 1} f(i - 1, j - k)
f(i,j)= 
k=0
∑
i−1
​	
 f(i−1,j−k)

修改一下有

\begin{aligned} f(i, j) &= \sum_{k = 0}^{i - 1} f(i - 1, j - k) \\ &= \sum_{k = 1}^{i} f(i - 1, j - k) + f(i - 1, j) - f(i - 1, j - i) \\ &= \sum_{k = 0}^{i - 1} f(i - 1, (j - 1) - k) + f(i - 1, j) - f(i - 1, j - i) \\ &= f(i, j - 1) + f(i - 1, j) - f(i - 1, j - i) \end{aligned}
f(i,j)
​	
  
= 
k=0
∑
i−1
​	
 f(i−1,j−k)
= 
k=1
∑
i
​	
 f(i−1,j−k)+f(i−1,j)−f(i−1,j−i)
= 
k=0
∑
i−1
​	
 f(i−1,(j−1)−k)+f(i−1,j)−f(i−1,j−i)
=f(i,j−1)+f(i−1,j)−f(i−1,j−i)
​	
 

方便起见，规定 f(i, j)=0(\forall j < 0)f(i,j)=0(∀j<0)，这样就避免了对 ii 和 jj 大小的讨论。（感谢评论区 @SJY 指出）

边界条件是 f(i, 0) = 1 (\forall i\ge 0)f(i,0)=1(∀i≥0)。

时间复杂度 O(nk)O(nk)。

执行用时 :
36 ms
, 在所有 C++ 提交中击败了
72.97%
的用户
内存消耗 :
18.8 MB
, 在所有 C++ 提交中击败了
19.39%
的用户
（时间还行，空间炸了）

上代码：
class Solution {
public:
    vector<vector<int>> vec;
    int kInversePairs(int n, int k) {
        vec = vector<vector<int>>(n + 1, vector<int>(k + 1, 0));
        vec[0][0] = 1;
        for (int i = 1; i <= n; ++i){
            vec[i][0] = 1;
            for (int j = 1; j <= k; ++j){
                vec[i][j] = vec[i - 1][j] + vec[i][j - 1];
                if (vec[i][j] >= 1000000007) // 取模
                    vec[i][j] -= 1000000007;
                if (j >= i){
                    vec[i][j] += 1000000007 - vec[i - 1][j - i];
                    if (vec[i][j] >= 1000000007) // 取模  
                        vec[i][j] -= 1000000007;
                }
            }
        }
        return vec[n][k];
    }
};