题目难度：HARD

给你一个整数方阵 arr ，定义「非零偏移下降路径」为：从 arr 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。

请你返回非零偏移下降路径数字和的最小值。

 

示例 1：

输入：arr = [[1,2,3],[4,5,6],[7,8,9]]
输出：13
解释：
所有非零偏移下降路径包括：
[1,5,9], [1,5,7], [1,6,7], [1,6,8],
[2,4,8], [2,4,9], [2,6,7], [2,6,8],
[3,4,8], [3,4,9], [3,5,7], [3,5,9]
下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。
 

提示：

1 <= arr.length == arr[i].length <= 200
-99 <= arr[i][j] <= 99

思路：周赛第四题，利用dp解，比较典型的题
dp表达式：
dp[i][j]表示第i行第j列的最小权之和
初始化第0行为0，因为没取值，并将剩下的每个dp值取最大
外部针对行列进行二重循环，内部再加一重循环，针对j==k（即不能跟之前的列相同）
否则就去前面的一项取最小值累加当前值（这里我看错题了，一维每行取到的数列数都不能相同）
然后遍历最后一行的最小值，返回结果即可
（又一次莫得AK，，）

上代码：
int dp[250][250];

class Solution {
public:    
    int minFallingPathSum(vector<vector<int>>& arr) {
        int n = arr.size(), m = arr[0].size();
        memset(dp[0], 0, sizeof(dp[0]));
        
        for (int i = 1; i <= n; i++){
            for (int j = 1; j <= m; j++){
                dp[i][j] = 4000000;
                for (int k = 1; k <= m; k++){
                    if (j == k) continue;
                    dp[i][j] = min(dp[i][j], dp[i - 1][k] + arr[i - 1][j - 1]);
                }
            }
        }
        
        int ans = 4000000;
        for (int i = 1; i <= m; i++) ans = min(ans, dp[n][i]);
        
        return ans;
    }
};