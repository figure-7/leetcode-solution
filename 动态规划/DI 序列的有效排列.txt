题目难度：HARD

我们给出 S，一个源于 {'D', 'I'} 的长度为 n 的字符串 。
（这些字母代表 “减少” 和 “增加”。）
有效排列 是对整数 {0, 1, ..., n} 的一个排列 P[0], P[1], ..., P[n]，使得对所有的 i：

如果 S[i] == 'D'，那么 P[i] > P[i+1]，以及；
如果 S[i] == 'I'，那么 P[i] < P[i+1]。
有多少个有效排列？
因为答案可能很大，所以请返回你的答案模 10^9 + 7.

 

示例：

输入："DID"
输出：5
解释：
(0, 1, 2, 3) 的五个有效排列是：
(1, 0, 3, 2)
(2, 0, 3, 1)
(2, 1, 3, 0)
(3, 0, 2, 1)
(3, 1, 2, 0)
 

提示：

1 <= S.length <= 200
S 仅由集合 {'D', 'I'} 中的字符组成。

思路：DP
接下来上题解区题解：

这里不再逐步扩大数字选择范围 来解决此问题。

而是一开始我们就能选择从0 到 n 的数字。

为了方便理解，我们发挥点想象力，可以将数字从小到大，如同木块堆叠起来。

每次就从中抽出一块放入排列P中。

这里我们还是以“DID” 为例，每次抽出一个数字块，这个块上的其他块掉下来补齐，整个过程保持从上到下，由大到小。


那么这里我们可以思考一个问题。

如果 我们第2次 抽取 第1层的木块，第1次应该抽取哪一层才能 构成降序‘D’。


我们罗列出所有情况。


我们观察可以发现一个规律，想要构成‘ D ’,即 p[ i - 1 ] > p[ i ]，就必须让上次抽取的层数 大于 本次抽取的层数 ；

想要构成‘ I ’，即p[ i - 1 ] < p[ i ] ，就必须让上次抽取的层数 小于等于 本次抽取的层数。

将那些层数的方案数 加起来 就是本次抽取层的方案数。

让 i 代表已经排了 i 个数字，现在应该排p[ i ] ，让 j 代表选择第 j 层数字（或 选择剩余未排序数字中第 j + 1小的数字），dp[ i ][ j ] 为方案数量。

我们就可以写出状态转移方程了。

dp[ i ][ j ] = dp[i - 1][ j + 1] + dp [i - 1][j + 2] + ... + dp[i - 1][ n - i ]      if (S[ i - 1 ] == 'D')   

dp[ i ][ j ] = dp[ i - 1 ][ j ] + dp [ i - 1][ j - 1 ] + ... + dp[ i - 1][ 0 ]       if (S[ i - 1 ]  == 'I')
我们可以发现，这与未优化的思路一的 方程相似。

不同的是，两个思路的 j 的限制范围不同，一个是逐步扩大，另一个是逐步减小；

直接就是dp[ n ][ 0 ]。

直接按照这个方程书写的时间复杂度是 O(N^3)O(N 
3
 )，与未优化的思路一程序结构相似，避免啰嗦，直接优化。

优化
同理，我们分别对比 dp[ i ][ j ] 和 dp[ i ][ j + 1]、dp[ i ][ j ] 和 dp[ i ][ j - 1]，获得优化后的方程。

dp[ i ][ j ] = dp[ i ][ j + 1 ] + dp[ i - 1 ][ j + 1 ]       if S[i - 1] == 'D'
dp[ i ][ j ] = dp[ i ][ j - 1 ] + dp[ i - 1 ][ j ]              if S[i - 1] == 'I'
考虑边界，i = 0时，可以选择范围为n 的数字，选择每种数字的方案数分别为1，所以初始化dp[ 0 ] 为1。
并且引入变量cur 处理 j 的边界问题。

执行用时 :
0 ms
, 在所有 C++ 提交中击败了
100.00%
的用户
内存消耗 :
7.5 MB
, 在所有 C++ 提交中击败了
100.00%
的用户
（时空都完杀！！！！！！）

上代码：
class Solution {
public:
    int numPermsDISequence(string S) {
        int n = S.length();
        vector<vector<int>> dp(n + 1,vector<int>(n + 1));
        int mod = 1000000007;
        int cur = 0;
        for (int j = 0; j <= n; j++) dp[0][j] = 1;
        for (int i = 1; i <= n;i++)
        {
            cur = 0;
            if(S[i - 1] == 'D')
            {
            	// 注意与思路一的范围区别
                for (int j = n - i; j >= 0; j-- )
                {
                	// 这里用cur 避免了一下边界问题
                    // 实际上就是 dp[i][j] = dp[i][j+1] + dp[i-1][j+1];
                    cur = ( cur + dp[i - 1][j + 1] ) %mod; 
                    dp[i][j] = cur ;
                } 
            }
            else
            {
                for(int j = 0 ; j <= n - i; j++)
                {
                    //  dp[i][j] = dp[i][j-1] + dp[i-1][j];
                    cur =  (cur + dp[i - 1][j])%mod ;
                    dp[i][j] = cur;
                } 
            }
        }
        return dp[n][0];
    }
};