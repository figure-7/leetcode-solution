题目难度：MEIDUM

附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。

你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。

按顺序 将这些书摆放到总宽度为 shelf_width 的书架上。

先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。

需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。

每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。

以这种方式布置书架，返回书架整体可能的最小高度。

 

示例：



输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4
输出：6
解释：
3 层书架的高度和为 1 + 3 + 2 = 6 。
第 2 本书不必放在第一层书架上。
 

提示：

1 <= books.length <= 1000
1 <= books[i][0] <= shelf_width <= 1000
1 <= books[i][1] <= 1000

思路：把给定二维数组两个坐标分别放入两个一维数组中，每次比较两两红坐标之间的差值
如果大于shelf_width就不能放入，直接break，再设置一个新数组保存结果，初值分别为1,2,3,4......这样最后结果就是对应最后一项的值
剩下的进二重循环，对每两个数先取最大高度，然后dp的到该值与前面的值加上最大高度的最小值，最后一项即为结果

上代码：
class Solution {
public:
    int minHeightShelves(vector<vector<int>>& books, int shelf_width) {
        int n,m,i,j,k,s[1005],a[1005],f[1005];
        n=books.size();
        m=shelf_width;
        s[0]=0;
        for(i=1;i<=n;i++)s[i]=s[i-1]+books[i-1][0];
        for(i=1;i<=n;i++)a[i]=books[i-1][1];
        memset(f,127,sizeof(f));
        for(f[0]=0,i=1;i<=n;i++)for(j=i,k=0;j;j--)
        {
            k=max(k,a[j]);
            if(s[i]-s[j-1]<=m)f[i]=min(f[i],f[j-1]+k);
            else break;
        }
        return f[n];
    }
};
