题目难度：HARD

你正在安装一个广告牌，并希望它高度最大。

这块广告牌将有两个钢制支架，两边各一个。

每个钢支架的高度必须相等。

你有一堆可以焊接在一起的钢筋 rods。

举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。

返回广告牌的最大可能安装高度。

如果没法安装广告牌，请返回 0。

 

示例 1：

输入：[1,2,3,6]
输出：6
解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。
示例 2：

输入：[1,2,3,4,5,6]
输出：10
解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。
示例 3：

输入：[1,2]
输出：0
解释：没法安装广告牌，所以返回 0。
 

提示：

0 <= rods.length <= 20
1 <= rods[i] <= 1000
钢筋的长度总和最多为 5000

思路：DP
接下来上题解区题解;
dp[i][j]代表前i个钢筋组成的两个框架高度差为j的时候的长度之和
由于考察到第i个钢筋的时候，其结果仅取决于上一个钢筋的结果，因此可以进行状态压缩为一维的dp。
状态转移方程详可代码注释。

执行用时 :
40 ms
, 在所有 C++ 提交中击败了
71.56%
的用户
内存消耗 :
24.8 MB
, 在所有 C++ 提交中击败了
29.41%
的用户
（时间不错，空间不太好）

上代码：
class Solution {
public:
    int tallestBillboard(vector<int>& rods) {
        int N = rods.size();
        int K = accumulate(rods.begin(), rods.end(), 0);
        vector<int> dp(K + 1, 0);
        for (int i = 1; i <= N; ++i) {
            auto dp1 = dp;
            for (int j = 0; j <= K; ++j) {
                // 钢筋高度差为j的时候其加和至少为j，因此不符合条件的跳过
                if (dp[j] < j) continue;
                // 加到长的那一侧
                int k = j + rods[i - 1];
                dp1[k] = max(dp1[k], dp[j] + rods[i - 1]);
                // 加到短的那一侧
                k = abs(j - rods[i - 1]);
                dp1[k] = max(dp1[k], dp[j] + rods[i - 1]);
            }
            swap(dp, dp1);
        }
        return dp[0] / 2;
    }
};