题目难度：MEDIUM

给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。

 

示例 1：

输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
输出：9
示例 2：

输入：grid = [[1,1,0,0]]
输出：1
 

提示：

1 <= grid.length <= 100
1 <= grid[0].length <= 100
grid[i][j] 为 0 或 1

思路：
（之前没过脑子，因为之前做过类似的，结果自己写了一个相邻为1的最大面积的，后来发现不对就没时间改完了，思路还是有的，，，）
dp表达式：dp[i][j]=dp[i][j-1]+g[i-1][j-1]; dp[i][j]=dp[i-1][j]+g[i-1][j-1]
原理：先用两个二位数组保存原数组横向和纵向相连1的个数
之后三重遍历，对每个点的后续分别计算最大的以1位界的正方形面积即可
具体操作实现见下面例子

例如上面例一：
g:
111
101
111

s1:
0000
0123 前面的这个3：(第一个判断该行横向是三个连续的1)
0112
0123 前面的这个3：(第二个判断该行横向是三个连续的1)

s2:
0000
0111
0212
0323 前面这行的第一个3：(第三个判断该列纵向是三个连续的1)  前面这行的第二个3：(第四个判断该列纵向是三个连续的1)

这四个判断结果都为3，正好都等于下标中的最大值，符合最大的以1位界的正方形条件
之后分别遍历取最大值再取平方即可

上代码：
class Solution {
public:
    int largest1BorderedSquare(vector<vector<int>>& g) {
        int s1[105][105],s2[105][105],ans=0;
        memset(s1,0,sizeof(s1));
        memset(s2,0,sizeof(s2));
        int n=g.size(),m=g[0].size(),i,j,k;
        for (i=1;i<=n;i++)
        {for (j=1;j<=m;j++)
        {s1[i][j]=s1[i][j-1]+g[i-1][j-1];
         s2[i][j]=s2[i-1][j]+g[i-1][j-1];
        }
        }
        for (i=1;i<=n;i++)
        {for (j=1;j<=m;j++)
        {for (k=1;i+k-1<=n&&j+k-1<=m;k++)
        {int l1=i,r1=i+k-1;
         int l2=j,r2=j+k-1;
         if (k<=ans) continue;
         if (s1[l1][r2]-s1[l1][l2-1]!=k) continue;	//第一个判断
         if (s1[r1][r2]-s1[r1][l2-1]!=k) continue;	//第二个判断
         if (s2[r1][r2]-s2[l1-1][r2]!=k) continue;	//第三个判断
         if (s2[r1][l2]-s2[l1-1][l2]!=k) continue;	//第四个判断
         ans=k;
        }
        }
        }
        return ans*ans;
    }
};