题目难度：HARD

你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。

你的目标是确切地知道 F 的值是多少。

无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？

 

示例 1：

输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。
如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。
如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
示例 2：

输入：K = 2, N = 6
输出：3
示例 3：

输入：K = 3, N = 14
输出：4
 

提示：

1 <= K <= 100
1 <= N <= 10000

思路：DP
（题都没看懂，看懂也不会。。。）接下来上题解区思路：
思路
从多少楼层多少个蛋最少要扔几次，转变为有多少个蛋扔几次可以测试出多少楼层。
如果只有 1 个蛋了，蛋不能碎，只能一层一层判断，所以有 T 次机会，就只可以判断出 T+1 层。
当只有 1 次机会时，无论有多少个蛋，你能测试出的楼层都只有 2 层。（T+1 == 2）
其他情况时，递归。【可以测试的楼层】 == 【蛋碎了，机会减1次】 + 【蛋没碎，机会减1次】

面试中遇到的子问题
一次面试中，面试官问了这道题的子问题。

有 2 个蛋，用一座 100 层的楼，要使用最少次数测试出蛋几层会碎（F）。
问第一次应该从几层扔。
分析题意，其实本质上是和本题是一样的。
相当于int ans = superEggDrop(2, 100);，得到 14 次。
因为最少需要 14 次，所以第 1 次扔在 14 层，如果蛋碎了，接下来 1~13 这个区间就只能一次一次尝试了。

接下来第二次扔蛋，因为扔过 1 次了，接下来的区间大小只有 12 ，只能够 15~26 ，所以扔到 27 层。

但是现场没有纸笔，不考代码，脑容量不够递归。
考虑到上面分析，推到最后一次，即区间大小是 0 ，再往前一次，区间大小是 1 。
所以在蛋的数量固定为 2 的情况下，次数和楼层的关系应该是：
扔 1 次，覆盖 1 层。
扔 2 次，覆盖 3 层。
扔 3 次，覆盖 6 层。
即：1 + 2 + 3 + ... + 14 > 100
所以答案是 14 次。

其它思考
这个问题简化后，其实和猜数字（猜一个数字，返回大了小了还是对了）是一个类型的，可以对比着思考。

执行用时 :
8 ms
, 在所有 C++ 提交中击败了
60.65%
的用户
内存消耗 :
8.5 MB
, 在所有 C++ 提交中击败了
58.46%
的用户
（都一般）

上代码：
class Solution {
public:
    int fun(int K, int T)	// 计算 K 个鸡蛋，扔 T 次，可以覆盖多少层楼
    {
        if (T == 1 || K == 1) return T + 1;
        return fun(K - 1, T - 1) + fun(K, T - 1);
    }

    int superEggDrop(int K, int N) 
    {
        int T = 1;	// 测试机会
        while (fun(K, T) <= N) T++;
        return T;
    }
};